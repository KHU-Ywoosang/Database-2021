#  관계 데이터 모델과 제약조건 

- RDDBMS 는 여전히 가장 널리 사용되는 DBMS 임
- 관계 데이터 모델을 최초로 구현한 가장 중요한 관계 DBMS 시제품은 System R
- 1970 년대에 E.F.Codd 가 제안 

관계 데이터 모델이 큰 성공을 거둔 요인 
- 간단한 테이블(Relation) 이용
- 중첩된 복잡한 구조가 없음 
- 다른 데이터 모델에 비해 이론이 잘 정립
- 관계 데이터베이스 설계와 효율적인 질의 처리 면에서 뛰어난 장점을 가짐
- 실무에서 표준 데이터베이스 응용에 대해 좋은 성능을 보임
- 숙련되지 않은 사용자도 쉽게 이해할 수 있음

## 2.1 관계 데이터 모델의 개념 


### 관계 데이터 모델
- 동일한 구조(Relation) 의 관점에서 모든 데이터를 논리적으로 구성
  * 논리적으로 연관된 데이터를 연결하기 위해 링크나 포인터를 사용하지 않음
- 선언적인 질의어를 통한 데이터 접근을 제공
  * 사용자는 원하는 데이터(what)만 명시하고, 어떻게 이 데이터를 찾을
것인가(how)는 명시할 필요가 없음
  *  응용 프로그램들은 데이터베이스 내의 레코드들의 어떠한 순서와도 무관하게
작성됨

###  기본적인 용어

- 릴레이션(relation): 2차원의 테이블 
- 레코드(record): 릴레이션의 각 행 
- 투플(tuple): 레코드를 좀더 공식적으로 부르는 용어. 특별한 말이 없으면 레코드와 동일
- 애트리뷰트(attribute): 릴레이션에서 이름을 가진 하나의 열

투플 : 행  
애트리뷰트 : 열


### 도메인(domain)

- 한 애트리뷰트에 나타날 수 있는 `값들의 집합` 
- 각 애트리뷰트의 도메인의 값들은 정수,문자열등의 원자값
- 프로그래밍 언어의 데이터타입과 유사 
- 동일한 도메인이 여러 애트리뷰트에서 사용될 수 있음
- 복잡한 애트리뷰나 다치(multivalued) 애트리뷰트는 허용되지 않음
  
도메인 정의 
- EMPNAME,EMPNAME,DNO 도메인을 정의
```
CREATE DOMAIN EMPNAME CHAR(10)
CREATE DOMAIN EMPNO INTEGER
CREATE DOMAIN DNO INTEGER
```

### 차수(degree) 와 카디날리티 (cadinality)

차수: 한 릴레이션에 들어 있는 애트리뷰트들의 수 (열의 수)
-유효한 릴레이션의 최소 차수는 1
- 릴레이션의 차수는 자주 바뀌지 않음
  스키마가 수정될때만 바뀜 

카디날리티: 릴레이션의 투플 수 (행의 수)
- 유효한 릴레이션은 카디날리티 0을 가질 수 있음 (행이 없을 때)
- 릴레이션의 카디날리티는 투플의 삽입과 삭제에따라 계속해서 변함 

### 용어 정리 

|공식적인 용어|자주 사용되는 용어|
|------|---| 
|릴레이션|테이블| 
|투플|행/레코드| 
|애트리뷰트|열| 

스키마, 차수(열의 수) : 미리 정해지고 잘 안바뀜  
릴레이션 인스턴스(데이터베이스 상태), 카디날리티(행의 수) : 데이터가 삽입, 삭제됨에 따라 변함

### null 값 

- 알려지지 않음 또는 적용할 수 없음을 나타내기 위해 널값을
사용
- 예: 사원 릴레이션에 새로운 사원에 관한 투플을 입력하는데, 신입
사원의 DNO(부서번호)가 결정되지 않았을 수 있음 사원이므로 DB에는 넣어야하고 부서번호는 부여할 수 없을 때 
- 널값은 숫자 도메인의 0이나 문자열 도메인의 공백 문자 또는 공백
문자열과 다름
- DBMS들마다 널값을 나타내기 위해 서로 다른 기호를 사용함


`empty string = ''` 은 `''` 라는 값이 존재하는 것이다  
빈값과 정확히 구분하기 위해 null 을 도입했다  

### 스키마(relation schema) 

- 릴레이션의 이름과 릴레이션의 애트리뷰트들의 집합
- 릴레이션을 위한 틀(framework)
- 표기법 
  * 릴레이션이름(애트리뷰트1, 애트리뷰트2, ... 애트리뷰트N)
  * 스키마는 애트리뷰트들의 집합 
  * 기본 키 애트리뷰트에는 밑줄 표시
  * 내포(intension)라고 함 

### 릴레이션 인스턴스(relation instance) 

- 릴레이션에 어느 시점에 들어 있는 투플들의 집합
- 시간의 흐름에 따라 계속 변함
- 일반적으로 릴레이션에는 현재의 인스턴스만 저장됨
- 외연(extension)이라고 함


![image](https://user-images.githubusercontent.com/68385605/111864058-31e91c00-89a2-11eb-81eb-bc0cc42e0434.png)


### 관계 데이터베이스(relational database) 스키마
- 하나 이상의 릴레이션 스키마들로 이루어짐

### 관계 데이터베이스 인스턴스
- 릴레이션 인스턴스들의 모임으로 구성됨


## 2.2 Relation 의 특성

릴레이션
  * 투플(행)들의 집합

릴레이션의 특성
  * 각 릴레이션은 오직 하나의 레코드 타입만 포함
  * 한 애트리뷰트(열) 내의 값들은 모두 같은 유형
  * 애트리뷰트들의 순서는 중요하지 않음
  * 동일한 투플이 두 개 이상 존재하지 않음
    - 이를 구분하는 `키` 가 존재하기 때문
  * 한 투플의 각 애트리뷰트는 원자값만 가져야 한다
  * 각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유하다
  * 투플들의 순서가 달라도 동일한 릴레이션이다 (키 순서가 달라도) 
  
원자값: 더이상 쪼개지지 않는 단위(업무적인 의미로)

 애트리뷰트는 원자값만을 가져야 하므로, 다음 `{ 영업, 기획}` 은 올바르지 못한 표현이다
|DEPTNO|DEPTNAME|
|------|---| 
|1|{ 영업, 기획}| 
|2|개발| 

릴레이션의 특성(계속)
-  각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유
-  투플들의 순서는 중요하지 않음


##  2.3 릴레이션의 키 

- 각 투플을 고유하게 식별할 수 있는 `하나 이상`의 애트리뷰트들의 모임이다
- 수퍼 키(superkey), 후보 키(candidate key), 기본 키(primary key), 대체
키(alternate key), 외래 키(foreign key) 로 나뉜다

### 수퍼 키 (superkey)

한 릴레이션 내의 특정 투플을 고유하게 식별하는 `하나`의 애트리뷰트 또는
애트리뷰트들의 `집합`이다  
- ex) 신용카드 회사의 고객 릴레이션에서 (신용카드번호, 주소) 또는
(주민등록번호, 이름) 또는 (주민등록번호)  

투플들을 고유하게 식별하는데 꼭 필요하지 않은 애트리뷰트들을 포함할
수 있다

### 후보 키 (candidate key)

각 투플을 고유하게 식별하는 `최소한`의 애트리뷰트들의 `모임`이다  
- ex) (신용카드번호, 주소)는 신용카드 회사의 고객 릴레이션의 후보 키가 아니지만 (신용카드번호)는 후보 키
- 모든 릴레이션에는 최소한 한 개 이상의 후보 키가 있다
- 후보 키도 두 개 이상의 애트리뷰트로 이루어질 수 있으며 이런 경우 `복합 키(composite key)` 라고 부른다


아래에서 (학번, 과목번호)가 후보 키가 될 수 있다

|학번|과목번호|학점|
|------|---|--| 
|1|CS1|A| 
|2|CS2|B|
|3|CS3|B|

### 기본 키 (primary key)
한 릴레이션에 후보 키가 두 개 이상 있으면 설계자 또는 데이터베이스
관리자가 이들 중에서 하나를 기본 키로 선정한다  

아래에서 후보 키 (학번, 과목번호)중 학번을 기본키로 선정한다
|학번|과목번호|학점|
|------|---|--| 
|1|CS1|A| 
|2|CS2|B|
|3|CS3|B| 
  
자연스러운 기본 키를 찾을 수 없는 경우에는 레코드 번호와 같이 종종
인위적인 키 애트리뷰트를 릴레이션에 추가할 수 있다 

### 대체 키 (alternate key)

기본 키가 아닌 후보 키를 의미한다
 
아래에서 후보 키 (학번, 과목번호)중 학번을 기본키로 선정한다면 과목번호는 대체키가 된다
|학번|과목번호|학점|
|------|---|--| 
|1|CS1|A| 
|2|CS2|B|
|3|CS3|B| 
  
### 외래 키 (foreign key)

어떤 릴레이션의 기본 키(primary key) 를 참조하는 애트리뷰트를 의미한다  


관계 데이터베이스에서 릴레이션들 간의 관계를 나타내기 위해서 사용된다   
외래 키 애트리뷰트는 참조되는 릴레이션의 기본 키와 동일한 도메인을 가져야 한다  
자신이 속한 릴레이션의 기본 키의 구성요소가 되거나 되지 않을 수 있다  

종류  
- 다른 릴레이션의 기본 키를 참조하는 외래 키 

![image](https://user-images.githubusercontent.com/68385605/112040415-8b12a480-8b88-11eb-97b9-d6ced0241d0a.png)

- 자체 릴레이션의 기본 키를 참조하는 외래 키 
![image](https://user-images.githubusercontent.com/68385605/112040495-a1b8fb80-8b88-11eb-8ad0-7e18a30bfaee.png)

- 기본 키의 구성요소가 되는 외래 키 
![image](https://user-images.githubusercontent.com/68385605/112040763-f0ff2c00-8b88-11eb-9e82-cfbad7e539cd.png)



![image](https://user-images.githubusercontent.com/68385605/112039830-d24c6580-8b87-11eb-9647-619e030ffef8.png)



## 2.4 무결성 제약조건 

### 데이터 무결성(data integrity)
- 데이터의 정확성 또는 유효성을 의미
- 일관된 데이터베이스 상태를 정의하는 규칙들을 묵시적으로 또는 명시적으로 정의함
- 데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로
응용 프로그램들은 일관성 조건을 검사할 필요가 없음

### 도메인 제약조건(domain constraint)
- 각 애트리뷰트 값이 반드시 원자값이어야 함
- 애트리뷰트 값의 디폴트 값, 가능한 값들의 범위 등을 지정할 수 있음
- 데이터 형식을 통해 값들의 유형을 제한하고, CHECK 제약 조건을 통해
값들의 범위를 제한할 수 있음
- SQL2는 도메인을 명시적으로 정의하는 것을 허용하지만,
오라클은 지원하지 않음
  

애트리뷰트에 도메인 제약을 지정  
```sql
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int CHECK (Age>=18)
);

//Mysql
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    CHECK (Age>=18)
);
``` 
여러 개의 애트리뷰트에 걸친 도메인 제약을 지정
```sql
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    City varchar(255),
    CONSTRAINT CHK_Person CHECK (Age>=18 AND City='Sandnes')
);
``` 

### 기본 키와 엔티티 무결성 제약조건(entity integrity constraint) 

- 기본 키가 각 투플들을 식별하기 위하여 사용되기 때문에 릴레이션의 기본
키를 구성하는 어떤 애트리뷰트도 널값을 가질 수 없다는 제약조건 
- 대체 키에는 적용되지 않음 
기본 키와 엔티티 무결성 제약조건(entity integrity constraint)
 기본 키가 각 투플들을 식별하기 위하여 사용되기 때문에 릴레이션의 기본
키를 구성하는 어떤 애트리뷰트도 널값을 가질 수 없다는 제약조건
 대체 키에는 적용되지 않음
- 기본키에만 적용. 널값을 가지지 않는 애트리뷰트여야 함 
- 사용자는 릴레이션을 생성하는 **데이터 정의문**에서 어떤 애트리뷰트가
릴레이션의 **기본 키**의 구성요소인가를 DBMS에게 알려줌


엔티티 : 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이
가능한 실세계의 물리적 또는 논리적 객체. 하나의 릴레이션에는 동일한 애트리뷰트들을 갖는 엔티티들만 속함




### 외래 키와 참조 무결성 제약조건(referential integrity constraint) 

- 참조 무결성 제약조건은 두 릴레이션의 연관된 투플들 사이의 일관성을
유지하는데 사용됨 
- 관계 데이터베이스가 **릴레이션**들로만 이루어지고, 릴레이션 사이의
**관계**들이 다른 릴레이션의 **기본 키를 참조하는** 것을 기반으로 하여
묵시적으로 표현되기 때문에 **외래 키**의 개념이 중요
- 릴레이션 R2의 외래 키가 릴레이션 R1의 기본 키를 참조할 때 참조 무결성
제약조건은 아래의 두 조건 중 하나가 성립되면 만족됨 
  * 외래 키의 값은 R1의 어떤 투플의 기본 키 값과 같다
  * 널 값을 가진다. 단, 외래 키가 자신을 포함하고 있는 릴레이션의 기본 키를
구성하고 있지 않음 : 
    * 릴레이션의 기본 키의 일부이면 널 값을 가질 수 없음 


**참조되는** 릴레이션에는 새로운 투플(행) 이 삽입되어도 참조무결성 제약조건 제약을 위반하지 않는다  
**참조하는** 릴레이션에 새로운 투플을 삽입할 때는 도메인 제약조건, 키
제약조건, 엔티티 무결성 제약조건 외에 참조 무결성 제약조건도 위배할 수
있음
 
![image](https://user-images.githubusercontent.com/68385605/112045244-fa3ec780-8b8d-11eb-8f4a-7f981bc64e05.png)





### 무결성 제약조건의 유지  

- 데이터베이스에 대한 갱신 연산은 삽입 연산, 삭제 연산, 수정 연산으로
구분함 
- DBMS는 각각의 갱신 연산에 대하여 데이터베이스가 무결성 제약조건들을
만족하도록 필요한 조치를 취함 
  * DBMS는 외래 키가 갱신되거나, 참조된 기본 키가 갱신되었을 때 참조
무결성 제약조건이 위배되지 않도록 해야 함 

### 삽입 

- **참조되는** 릴레이션에 새로운 투플이 **삽입**되면 참조 무결성 제약조건은
**위배되지 않음**
- DEPARTMENT에 새로 삽입되는 투플의 기본 키 애트리뷰트의 값에
따라서는 도메인 제약조건, 키 제약조건, 엔티티 무결성 제약조건 등을
위배할 수 있음
- **참조하는** 릴레이션에 새로운 투플을 **삽입**할 때는 도메인 제약조건, 키
제약조건, 엔티티 무결성 제약조건 외에 참조 무결성 제약조건도 **위배할 수
있음**

### 삭제 
- **참조하는** 릴레이션에서 투플이 삭제되면 도메인 제약조건, 키 제약조건,
엔티티 무결성 제약조건, 참조 무결성 제약조건 등 모든 제약조건을
**위배하지 않음**
- **참조되는** 릴레이션에서 투플이 **삭제**되면 참조 무결성 제약조건을 **위배**하는
경우가 생기거나 생기지 않을 수 있음 


### 참조 무결성 제약조건을 만족시키기 위해서 DBMS가 제공하는 옵션

제한(restricted) 
- 위배를 야기한 연산을 단순히 거절 
  * ex) 참조 무결성 제약조건을 위배하는 삭제연산을 거절
연쇄(cascade)
- **참조되는** 릴레이션에서 투플을 **삭제**하고, **참조하는** 릴레이션에서 이 투플을
참조하는 투플들도 함께 **삭제**

널값(nullify)
- **참조되는** 릴레이션에서 투플을 **삭제**하고, 참조하는 릴레이션에서 이 투플을
**참조하는** 투플들의 **외래 키**에 **널값**을 삽입
디폴트값
- 널값을 넣는 대신에 디폴트값을 넣는다는 것을 제외하고는 바로 위의 옵션과
비슷
```sql
CREATE TABLE EMPLOYEE (
    EMPNO int primary key,
    EMPNAME varchar(100),
    DNO int DEFAULT 1,
    CONSTRAINT EMPLOYEE_DNO_FK REFERENCES DEPARTMENT(DNO)
    ON DELETE SET DEFAULT
)
``` 
삭제 옵션 키워드  
`ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT }`
 
NO ACTION : 삭제 제한   
CASCADE: 연쇄삭제  
SET NUL: 널값 지정  
SET DEFAULT : 기본값 지정  

수정
- DBMS는 수정하는 애트리뷰트가 **기본 키인지 외래 키**인지 검사함
- 수정하려는 애트리뷰트가 기본 키도 아니고 외래 키도 아니면 수정 연산이
참조 무결성 제약조건을 위배하지 않음
- 기본 키나 외래 키를 **수정**하는 것은 하나의 투플을 **삭제**하고 새로운 투플을 그 자리에 **삽입**하는 것과 유사하므로, 삽입 및 삭제에서 설명한 제한, 연쇄, 널값, 디폴트값 **규칙이 수정 연산에도 적용**됨
- 오라클에서는 수정 연산에 대해 제한적으로 참조 무결성 제약조건을 유지 
  - 기본키는 절대 삭제되서는 안됨 
  - 기본 키는 변경하면 안된다는 철학
 